// This file is reserved for implementing commands
// We currently implement two commands
// 1: Key Value Storage (CommandName: KVStore)
// 2: Distributed Lock (CommandName: DLock)

// You can edit this file to add new commands for Raft
// as long as your command satisfies the interface standard

package storage

import (
	"encoding/json"
)

// inheritted from Command
// always has the default CommandName as "KVStore"
type CommandKVStore struct {
	Command
}

type KeyValue struct {
	Key string `json:"key"`
	Value []byte `json:"value"`
}

func NewCommandKVStore(key string, value []byte) (*CommandKVStore, error) {
	
	// key value object pending to be marshalled
	keyValue := new(KeyValue)
	keyValue.Key = key
	keyValue.Value = value

	// marshal the kv object
	encodedKeyValue, err := json.Marshal(keyValue)
	if err != nil {
		return nil, err
	}

	// construct the command object
	commandKVStore := new(CommandKVStore)
	// note that "KVStore" is predetermined for CommandKVStore
	commandKVStore.SetCommandName("KVStore")
	commandKVStore.SetCommandContent(encodedKeyValue)

	return commandKVStore, nil
}

func (c *CommandKVStore) SetAsKVStore(keyValue *KeyValue) (error){

	// marshal the kv object
	encodedKeyValue, err := json.Marshal(keyValue)
	if err != nil {
		return err
	}

	// construct the command object
	commandKVStore := new(CommandKVStore)
	// note that "KVStore" is predetermined for CommandKVStore
	commandKVStore.SetCommandContent(encodedKeyValue)

	return nil
}

func (c *CommandKVStore) GetAsKVStore() (*KeyValue, error){
	
	// unmarshal the kv object
	decodedKeyValue := new(KeyValue)
	err := json.Unmarshal(c.GetCommandContent(), &decodedKeyValue)
	if err != nil {
		return nil, err
	}

	return decodedKeyValue, nil
}

// inheritted from Command
// always has the default CommandName as "DLock"
type CommandDLock struct {
	Command
}

// OrigOwner indicates the original owner of this lock
// NewOwner indicates the current owner of this lock (after lock switch)
// Timestamp is generated by time.Now().UnixNano(), by user. 
type LockInfo struct {
	LockId uint32 `json:"lock_id"`
	LockName string `json:"lock_name"`
	OrigOwner string `json:"orig_owner"`
	NewOwner string `json:"new_owner"`
	Timestamp int64 `json:"timestamp"`
}

func NewCommandDLock(lock_id uint32, lock_name string, orig_owner string,
									new_owner string, timestamp int64) (*CommandDLock, error) {
	
	// dlock object object pending to be marshalled
	lockInfo := new(LockInfo)
	lockInfo.LockId = lock_id
	lockInfo.LockName = lock_name
	lockInfo.OrigOwner = orig_owner
	lockInfo.NewOwner = new_owner
	lockInfo.Timestamp = timestamp

	// marshal the dlock object
	encodedLockInfo, err := json.Marshal(lockInfo)
	if err != nil {
		return nil, err
	}

	// construct the command object
	commandDLock := new(CommandDLock)
	// note that ""DLock" is predetermined for CommandDLock
	commandDLock.SetCommandName("DLock")
	commandDLock.SetCommandContent(encodedLockInfo)

	return commandDLock, nil
}

func (c *CommandDLock) SetAsDLockInfo(lockInfo *LockInfo) (error){

	// marshal the dlock object
	encodedLockInfo, err := json.Marshal(lockInfo)
	if err != nil {
		return err
	}

	// construct the command object
	commandDLock := new(CommandDLock)
	// note that ""DLock" is predetermined for CommandDLock
	commandDLock.SetCommandContent(encodedLockInfo)

	return nil
}

func (c *CommandDLock) GetAsDLockInfo() (*LockInfo, error){
	
	// unmarshal the kv object
	decodedLockInfo := new(LockInfo)
	err := json.Unmarshal(c.GetCommandContent(), decodedLockInfo)
	if err != nil {
		return nil, err
	}

	return decodedLockInfo, nil
}