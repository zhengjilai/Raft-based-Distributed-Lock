// This file is reserved for implementing commands
// We currently implement two commands
// 1: Key Value Storage (CommandName: KVStore)
// 2: Distributed Lock (CommandName: DLock)

// You can edit this file to add new commands for Raft
// as long as your command satisfies the interface standard

// Warning: except implementing an interface for Command
// at bottom, a function called NewCommandFromRaw(string, []byte) should also be implemented

package storage

import (
	"encoding/json"
)

// inherited from Command
// always has the default CommandName as "KVStore"
type CommandKVStore struct {
	Command
}

type KeyValue struct {
	// Key should be unique
	Key string `json:"key"`
	Value []byte `json:"value"`
}

func NewCommandKVStore(key string, value []byte) (*CommandKVStore, error) {
	
	// key value object pending to be marshalled
	keyValue := new(KeyValue)
	keyValue.Key = key
	keyValue.Value = value

	// marshal the kv object
	encodedKeyValue, err := json.Marshal(keyValue)
	if err != nil {
		return nil, err
	}

	// construct the command object
	commandKVStore := new(CommandKVStore)
	// note that "KVStore" is predetermined for CommandKVStore
	commandKVStore.SetCommandName("KVStore")
	commandKVStore.SetCommandContent(encodedKeyValue)
	// KVStore interface
	commandKVStore.commandOperator = commandKVStore

	return commandKVStore, nil
}

func (c *CommandKVStore) SetAsKVStore(keyValue *KeyValue) error {

	// marshal the kv object
	encodedKeyValue, err := json.Marshal(keyValue)
	if err != nil {
		return err
	}

	// construct the command object
	commandKVStore := new(CommandKVStore)
	// note that "KVStore" is predetermined for CommandKVStore
	commandKVStore.SetCommandContent(encodedKeyValue)

	return nil
}

func (c *CommandKVStore) GetAsKVStore() (*KeyValue, error){
	
	// unmarshal the kv object
	decodedKeyValue := new(KeyValue)
	err := json.Unmarshal(c.GetCommandContent(), &decodedKeyValue)
	if err != nil {
		return nil, err
	}

	return decodedKeyValue, nil
}

// the fast index interface specific to KVStore
// format: "KVStore:Key"
func (c *CommandKVStore) GetFastIndex() (string, error) {
	kvStore, err := c.GetAsKVStore()
	if err != nil {
		return "", err
	}
	// the fast index is set as key
	return "KVStore:" + kvStore.Key, nil
}


// inherited from Command
// always has the default CommandName as "DLock"
type CommandDLock struct {
	Command
}

// OrigOwner indicates the original owner of this lock
// NewOwner indicates the current owner of this lock (after lock switch)
// Timestamp is generated by time.Now().UnixNano(), by user. 
type LockInfo struct {
	// LockNonce should be unique, accumulating from 1
	LockNonce uint32 `json:"lock_nonce"`
	// LockName should also be unique, will be used as fastIndex
	LockName string `json:"lock_name"`
	NewOwner string `json:"new_owner"`
	// the creating time stamp, unit: ns
	Timestamp int64 `json:"timestamp"`
	// expire time for this lock, unit: ns
	Expire int64 `json:"expire"`
}

func NewCommandDLock(lockNonce uint32, lockName string,
	newOwner string, timestamp int64, expire int64) (*CommandDLock, error) {
	
	// dlock object object pending to be marshalled
	lockInfo := new(LockInfo)
	lockInfo.LockNonce = lockNonce
	lockInfo.LockName = lockName
	lockInfo.NewOwner = newOwner
	lockInfo.Timestamp = timestamp
	lockInfo.Expire = expire

	// marshal the dlock object
	encodedLockInfo, err := json.Marshal(lockInfo)
	if err != nil {
		return nil, err
	}

	// construct the command object
	commandDLock := new(CommandDLock)
	// note that ""DLock" is predetermined for CommandDLock
	commandDLock.SetCommandName("DLock")
	commandDLock.SetCommandContent(encodedLockInfo)
	commandDLock.commandOperator = commandDLock

	return commandDLock, nil
}

func (c *CommandDLock) SetAsDLockInfo(lockInfo *LockInfo) error {

	// marshal the dlock object
	encodedLockInfo, err := json.Marshal(lockInfo)
	if err != nil {
		return err
	}

	// construct the command object
	commandDLock := new(CommandDLock)
	// note that ""DLock" is predetermined for CommandDLock
	commandDLock.SetCommandContent(encodedLockInfo)

	return nil
}

func (c *CommandDLock) GetAsDLockInfo() (*LockInfo, error){
	
	// unmarshal the kv object
	decodedLockInfo := new(LockInfo)
	err := json.Unmarshal(c.GetCommandContent(), decodedLockInfo)
	if err != nil {
		return nil, err
	}

	return decodedLockInfo, nil
}

// the fast index interface specific to DLockInfo
// format: "DLock:LockName"
func (c *CommandDLock) GetFastIndex() (string, error) {
	dLockInfo, err := c.GetAsDLockInfo()
	if err != nil {
		return "", err
	}
	// the fast index is set as LockName
	return "DLock:" + dLockInfo.LockName, nil
}

// a help function for getting a Command from raw data
// Warning: you should change this function to use the functionality of FastIndex
// Be cautious to use this function !!!!!
func NewCommandFromRaw(commandName string, commandContent []byte) CommandOperator {

	// construct the object according to
	if commandName == "KVStore" {
		// construct the command object
		commandKVStore := new(CommandKVStore)
		// note that "KVStore" is predetermined for CommandKVStore
		commandKVStore.SetCommandName("KVStore")
		commandKVStore.SetCommandContent(commandContent)
		commandKVStore.commandOperator = commandKVStore
		return commandKVStore
	} else if commandName == "DLock" {
		// construct the command object
		commandDLock := new(CommandDLock)
		// note that ""DLock" is predetermined for CommandDLock
		commandDLock.SetCommandName("DLock")
		commandDLock.SetCommandContent(commandContent)
		commandDLock.commandOperator = commandDLock
		return commandDLock
	}
	return nil
}